<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scoreline</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 14px;
            line-height: 1.4;
            background: #fafafa;
            color: #1a1a1a;
            padding: 16px;
        }

        .container {
            max-width: 640px;
            margin: 0 auto;
        }

        h1 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        /* Dense layout sections */
        .section {
            margin-bottom: 12px;
        }

        .section-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            margin-bottom: 4px;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            font-size: 14px;
            font-family: inherit;
            font-weight: 500;
            border: 1px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            outline: none;
            transition: all 0.15s;
        }

        .btn:focus {
            box-shadow: 0 0 0 2px rgba(0, 102, 204, 0.3);
        }

        /* Test controls */
        .test-controls {
            margin-top: 16px;
            padding-top: 12px;
        }

        /* Only add border-top to subsequent test-controls sections */
        .test-controls + .test-controls {
            border-top: 1px solid #e0e0e0;
        }

        .test-slider {
            width: 100%;
            margin: 8px 0;
        }

        .test-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
        }

        .hint {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }

        .hidden { display: none; }

        /* Strip visualization */
        .strip-preview {
            height: 20px;
            background: #1a1a1a;
            border-radius: 3px;
            display: flex;
            overflow: hidden;
            margin: 8px 0;
            position: relative;
        }

        .strip-segment {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
        }

        .strip-segment.home {
            background: linear-gradient(90deg, var(--home-color-1, #22c55e) 0%, var(--home-color-2, #166534) 100%);
        }

        .strip-segment.away {
            background: linear-gradient(90deg, var(--away-color-1, #3b82f6) 0%, var(--away-color-2, #1d4ed8) 100%);
        }

        .strip-segment.buffer {
            background: #000;
        }

        .strip-segment.divider {
            background: linear-gradient(90deg, #c85000, #ff8c00, #c85000);
            animation: divider-pulse 1.5s ease-in-out infinite;
        }

        @keyframes divider-pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .dignity-marker {
            position: absolute;
            bottom: -12px;
            font-size: 10px;
            color: #dc2626;
            line-height: 1;
            transform: translateX(-50%);
        }

        .dignity-marker::after {
            content: '‚åÉ';
        }

        .dignity-marker[style*="right"] {
            transform: translateX(50%);
        }

        .strip-label {
            position: absolute;
            font-size: 9px;
            font-weight: 600;
            color: rgba(255,255,255,0.9);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        /* Settings panel */
        .instance-settings {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
        }

        .settings-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 14px;
            color: #666;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .settings-toggle:hover {
            background: rgba(0,0,0,0.05);
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 8px 0;
        }

        .settings-label {
            font-size: 11px;
            color: #666;
            min-width: 80px;
        }

        .settings-value {
            font-family: "SF Mono", Monaco, Consolas, monospace;
            font-size: 12px;
            color: #333;
            min-width: 100px;
        }

        .settings-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 2px;
            outline: none;
        }

        .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #0066cc;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Watch teams */
        .watch-teams {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin: 6px 0;
        }

        .watch-team-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: #e0f2fe;
            border: 1px solid #7dd3fc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            font-family: monospace;
        }

        .watch-team-tag button {
            background: none;
            border: none;
            cursor: pointer;
            color: #0369a1;
            font-size: 12px;
            padding: 0;
            line-height: 1;
        }

        .watch-team-tag button:hover {
            color: #dc2626;
        }

        .watch-add-form {
            display: flex;
            gap: 4px;
            margin-top: 6px;
        }

        .watch-add-form select {
            padding: 4px 6px;
            font-size: 11px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .watch-add-form button {
            padding: 4px 8px;
            font-size: 11px;
            background: #22c55e;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .watch-add-form button:disabled {
            background: #86efac;
            cursor: not-allowed;
        }

        /* Simulator preset buttons */
        .sim-preset-btn {
            padding: 4px 10px;
            font-size: 11px;
            font-family: inherit;
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .sim-preset-btn:hover {
            background: #e5e5e5;
            border-color: #ccc;
        }

        .sim-preset-btn:active {
            transform: scale(0.95);
            background: #d1d5db;
        }

        .sim-preset-btn.active {
            background: #dbeafe;
            border-color: #3b82f6;
            color: #1d4ed8;
        }

        .sim-preset-btn.stop-btn {
            background: #fee2e2;
            border-color: #fca5a5;
        }

        .sim-preset-btn.stop-btn:not(.enabled) {
            background: #f5f5f5;
            border-color: #e5e5e5;
            color: #aaa;
            cursor: default;
        }

        .sim-preset-btn.stop-btn:not(.enabled):active {
            transform: none;
        }

        .sim-preset-btn.stop-btn.enabled:hover {
            background: #fecaca;
            border-color: #f87171;
        }

        /* Simulator target toggles */
        .sim-targets {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin: 8px 0;
            padding: 8px;
            background: #f9fafb;
            border-radius: 6px;
        }

        .sim-target-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
        }

        .sim-target-label {
            font-size: 12px;
            font-family: monospace;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sim-target-label .live-badge {
            font-size: 9px;
            color: #22c55e;
            font-weight: 600;
        }

        /* Toggle switch */
        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
            cursor: pointer;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            inset: 0;
            background: #d1d5db;
            border-radius: 10px;
            transition: 0.2s;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            left: 2px;
            bottom: 2px;
            background: white;
            border-radius: 50%;
            transition: 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .toggle-switch input:checked + .toggle-slider {
            background: #dc2626;
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(16px);
        }

        /* Simulator settings panel */
        .sim-settings {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e5e7eb;
        }

        .sim-settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 16px;
        }

        .sim-setting-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sim-setting-label {
            font-size: 11px;
            color: #666;
            min-width: 70px;
        }

        .sim-setting-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 2px;
            outline: none;
        }

        .sim-setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #dc2626;
            border-radius: 50%;
            cursor: pointer;
        }

        .sim-setting-value {
            font-family: monospace;
            font-size: 11px;
            color: #333;
            min-width: 40px;
            text-align: right;
        }

        /* Reusable settings grid for instance panels */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 16px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-label {
            font-size: 11px;
            color: #666;
            min-width: 70px;
        }

        .setting-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 2px;
            outline: none;
        }

        .setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #0066cc;
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-value {
            font-family: monospace;
            font-size: 11px;
            color: #333;
            min-width: 40px;
            text-align: right;
        }

        /* Edit button */
        .edit-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 12px;
            color: #666;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .edit-btn:hover {
            background: rgba(0,0,0,0.05);
            color: #0066cc;
        }

        /* Edit form inline */
        .edit-form {
            background: #fefce8;
            border: 1px solid #fde047;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
        }

        .edit-form-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .edit-form-row input {
            padding: 6px 8px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .edit-form-row input[type="text"] {
            flex: 2;
            min-width: 120px;
        }

        .edit-form-row input[type="number"] {
            flex: 1;
            min-width: 70px;
        }

        /* Mobile responsive */
        @media (max-width: 500px) {
            /* Stack add/edit form inputs */
            .add-wled-inputs,
            .edit-form-row {
                flex-direction: column;
            }

            .add-wled-inputs input,
            .edit-form-row input {
                min-width: 100%;
            }

            /* Stack settings grids to single column */
            .settings-grid,
            .sim-settings-grid {
                grid-template-columns: 1fr;
                gap: 12px 16px;
            }

            /* Bigger touch targets for sliders */
            .setting-row,
            .sim-setting-row {
                padding: 4px 0;
            }

            .setting-slider,
            .sim-setting-slider {
                height: 8px;
            }

            .setting-slider::-webkit-slider-thumb,
            .sim-setting-slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Scoreline</h1>

        <!-- WLED Instances -->
        <div class="test-controls">
            <div class="section-label" style="display: flex; justify-content: space-between; align-items: center;">
                <span>WLED Instances</span>
                <div style="display: flex; gap: 4px;">
                    <button id="add-wled-btn" class="btn" style="padding: 4px 10px; font-size: 12px; background: #f5f5f5; border: 1px solid #ccc;">+ Add WLED</button>
                    <button id="scan-btn" class="btn" style="padding: 4px 10px; font-size: 12px; background: #f5f5f5; border: 1px solid #ccc;">Scan Network</button>
                </div>
            </div>
            <div id="wled-list"></div>
            <div id="add-wled-form" class="hidden" style="margin-top: 8px; padding: 8px; background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 4px;">
                <div style="font-size: 11px; font-weight: 600; color: #166534; margin-bottom: 8px;">Add WLED Device</div>
                <div class="add-wled-inputs" style="display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap;">
                    <input type="text" id="add-wled-host" placeholder="IP / Hostname" style="flex: 2; min-width: 120px; padding: 6px 8px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;">
                    <input type="number" id="add-wled-start" placeholder="Start" value="0" style="flex: 1; min-width: 60px; padding: 6px 8px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;">
                    <input type="number" id="add-wled-end" placeholder="End" style="flex: 1; min-width: 60px; padding: 6px 8px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;">
                </div>
                <div style="display: flex; gap: 8px;">
                    <button id="add-wled-submit" class="btn" style="padding: 4px 12px; font-size: 12px; background: #22c55e; color: white; border: none;">Add</button>
                    <button id="add-wled-cancel" class="btn" style="padding: 4px 12px; font-size: 12px; background: #f5f5f5; border: 1px solid #ccc;">Cancel</button>
                </div>
            </div>
            <div id="discovered-list" class="hidden" style="margin-top: 8px; padding: 8px; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 4px;">
                <div style="font-size: 11px; font-weight: 600; color: #0369a1; margin-bottom: 4px;">Discovered on network:</div>
                <div id="discovered-devices"></div>
            </div>
            <div class="hint">Configured in config/settings.yaml</div>
        </div>

        <!-- Simulator -->
        <div class="test-controls">
            <div class="section-label">üéÆ Simulator</div>

            <!-- Target toggles -->
            <div class="sim-targets" id="sim-targets">
                <!-- Populated by JS -->
            </div>

            <!-- Team selection -->
            <div class="section" style="display: flex; gap: 8px; margin-bottom: 8px;">
                <select id="sim-league" style="flex: 1;">
                    <option value="">League...</option>
                </select>
                <select id="sim-home" style="flex: 1;" disabled>
                    <option value="">Home...</option>
                </select>
                <select id="sim-away" style="flex: 1;" disabled>
                    <option value="">Away...</option>
                </select>
            </div>

            <!-- Strip Preview -->
            <div id="sim-preview-container" style="margin-bottom: 8px;">
                <div class="strip-preview" id="sim-preview">
                    <!-- Populated by updateSimPreview -->
                </div>
            </div>

            <!-- Win percentage slider -->
            <div class="test-label">
                <span id="sim-home-label">Home</span>
                <span id="test-pct">50%</span>
                <span id="sim-away-label">Away</span>
            </div>
            <input type="range" id="test-slider" class="test-slider"
                   min="0" max="100" value="50">

            <!-- Scenario Presets -->
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin: 8px 0;">
                <button onclick="playScenario(50)" class="sim-preset-btn">Nail-biter</button>
                <button onclick="playScenario(80)" class="sim-preset-btn">Dominant</button>
                <button onclick="playScenario(95)" class="sim-preset-btn">Blowout</button>
                <button onclick="playComeback()" class="sim-preset-btn anim-btn" data-anim="comeback">Comeback</button>
                <button onclick="playCollapse()" class="sim-preset-btn anim-btn" data-anim="collapse">Collapse</button>
                <button onclick="playOvertime()" class="sim-preset-btn anim-btn" data-anim="overtime">Overtime</button>
                <button onclick="playMomentum()" class="sim-preset-btn anim-btn" data-anim="momentum">Momentum</button>
                <button onclick="playBuzzerBeater()" class="sim-preset-btn anim-btn" data-anim="buzzer">Buzzer</button>
            </div>
            <div style="display: flex; gap: 6px; margin-bottom: 8px; justify-content: flex-end;">
                <button onclick="stopSim()" id="stop-btn" class="sim-preset-btn stop-btn">‚èπ Stop</button>
                <button onclick="saveSimDefaults()" id="save-sim-btn" class="sim-preset-btn" title="Save current league/teams/pct as default">üíæ</button>
            </div>

            <!-- Display Settings -->
            <div class="sim-settings" id="sim-settings">
                <div class="section-label" style="margin-bottom: 8px;">Display Settings</div>
                <div class="sim-settings-grid">
                    <div class="sim-setting-row">
                        <span class="sim-setting-label">Min Dignity</span>
                        <input type="range" class="sim-setting-slider" id="sim-dignity" min="1" max="20" value="5" oninput="updateSimSettings()">
                        <span class="sim-setting-value" id="sim-dignity-value">5%</span>
                    </div>
                    <div class="sim-setting-row">
                        <span class="sim-setting-label">Buffer</span>
                        <input type="range" class="sim-setting-slider" id="sim-buffer" min="0" max="20" value="4" oninput="updateSimSettings()">
                        <span class="sim-setting-value" id="sim-buffer-value">4px</span>
                    </div>
                    <div class="sim-setting-row">
                        <span class="sim-setting-label">Divider</span>
                        <input type="range" class="sim-setting-slider" id="sim-divider" min="2" max="30" value="6" oninput="updateSimSettings()">
                        <span class="sim-setting-value" id="sim-divider-value">6px</span>
                    </div>
                    <div class="sim-setting-row">
                        <span class="sim-setting-label">Style</span>
                        <select id="sim-divider-preset" onchange="updateSimSettings()" style="flex: 1; padding: 2px 4px; font-size: 11px; border: 1px solid #ccc; border-radius: 4px;">
                            <option value="classic">Classic</option>
                            <option value="intense">Intense</option>
                            <option value="ice">Ice</option>
                            <option value="pulse">Pulse</option>
                            <option value="chaos">Chaos</option>
                        </select>
                    </div>
                    <div class="sim-setting-row">
                        <span class="sim-setting-label">Chase Speed</span>
                        <input type="range" class="sim-setting-slider" id="sim-chase-speed" min="50" max="255" value="185" oninput="updateSimSettings()">
                        <span class="sim-setting-value" id="sim-chase-speed-value">185</span>
                    </div>
                    <div class="sim-setting-row">
                        <span class="sim-setting-label">Intensity</span>
                        <input type="range" class="sim-setting-slider" id="sim-chase-intensity" min="50" max="255" value="190" oninput="updateSimSettings()">
                        <span class="sim-setting-value" id="sim-chase-intensity-value">190</span>
                    </div>
                </div>
            </div>

            <div class="hint" style="margin-top: 8px;">Toggle instances, pick teams, adjust settings. Changes apply instantly to targeted strips.</div>
        </div>
    </div>

    <script>
        // State
        let leagues = [];
        let instanceStates = [];  // From /api/instances

        async function loadInstances() {
            const resp = await fetch('/api/instances');
            instanceStates = await resp.json();
            renderInstanceCards();
            renderSimTargetToggles();
            updateStopButton();
        }

        function updateStopButton() {
            const btn = document.getElementById('stop-btn');
            const hasSimulating = instanceStates.some(i => i.simulating) || autoPlayInterval;
            if (hasSimulating) {
                btn.classList.add('enabled');
            } else {
                btn.classList.remove('enabled');
            }
        }

        // Track which instance settings panels are expanded
        let expandedSettings = new Set();
        // Track which instances are being edited
        let editingInstances = new Set();

        function renderInstanceCards() {
            const list = document.getElementById('wled-list');
            if (instanceStates.length === 0) {
                list.innerHTML = '<div class="hint" style="margin: 8px 0; color: #dc2626;">No WLED instances configured</div>';
                return;
            }

            list.innerHTML = instanceStates.map(inst => {
                const isWatching = inst.watching;
                const hasWatchTeams = (inst.watch_teams || []).length > 0;
                const isOverride = isWatching && hasWatchTeams;  // Manually watching when auto-watch is configured

                const isExpanded = expandedSettings.has(inst.host);
                const hostId = inst.host.replace(/\./g, '-');

                // Calculate strip preview segments
                const totalPixels = inst.end - inst.start;
                const minPct = inst.min_team_pct || 0.05;
                const contestedPx = inst.contested_zone_pixels || 6;
                const darkBufferPx = inst.dark_buffer_pixels || 4;
                const battleZone = contestedPx + (darkBufferPx * 2);
                const availablePixels = totalPixels - battleZone;
                const minDignityPixels = Math.round(availablePixels * minPct);

                // Preview at 50/50 by default, or use live win pct if watching
                const previewPct = isWatching && inst.home_win_pct !== undefined ? inst.home_win_pct : 0.5;
                const clampedPct = Math.max(minPct, Math.min(1 - minPct, previewPct));
                const homePixels = Math.round(availablePixels * clampedPct);
                const awayPixels = availablePixels - homePixels;

                // Convert to percentages for CSS
                const homePctWidth = (homePixels / totalPixels * 100).toFixed(1);
                const bufferPctWidth = (darkBufferPx / totalPixels * 100).toFixed(1);
                const dividerPctWidth = (contestedPx / totalPixels * 100).toFixed(1);
                const awayPctWidth = (awayPixels / totalPixels * 100).toFixed(1);

                // Divider gradient based on preset
                const presetGradients = {
                    classic: 'linear-gradient(90deg, #c85000, #ff8c00, #c85000)',
                    intense: 'linear-gradient(90deg, #cc0000, #ff3300, #cc0000)',
                    ice: 'linear-gradient(90deg, #4080ff, #80b0ff, #4080ff)',
                    pulse: 'linear-gradient(90deg, #aaa, #ddd, #aaa)',
                    chaos: 'linear-gradient(90deg, #ff4400, #ff8800, #ff4400)',
                };
                const dividerGradient = presetGradients[inst.divider_preset] || presetGradients.classic;

                // Status badges
                const simBadge = inst.simulating
                    ? `<span style="font-size: 10px; color: #dc2626; font-weight: 500;">SIM</span>`
                    : '';
                const statusBadge = isWatching
                    ? (isOverride
                        ? `<span style="font-size: 10px; color: #d97706; font-weight: 600; background: #fef3c7; padding: 2px 6px; border-radius: 3px;">‚ö° OVERRIDE</span>`
                        : `<span style="font-size: 11px; color: #22c55e; font-weight: 600;">‚óè LIVE</span>`)
                    : '';

                // Stop/Resume button
                const stopButton = isWatching
                    ? (hasWatchTeams
                        ? `<button onclick="stopInstance('${inst.host}')" class="btn" style="padding: 4px 12px; font-size: 12px; background: #6366f1; color: white; border: none;">‚Ü© Resume Auto-Watch</button>`
                        : `<button onclick="stopInstance('${inst.host}')" class="btn" style="padding: 4px 12px; font-size: 12px; background: #dc2626; color: white; border: none;">Stop</button>`)
                    : '';

                const isEditing = editingInstances.has(inst.host);

                return `
                <div class="instance-card" style="background: ${isWatching ? (isOverride ? '#fffbeb' : '#f0fdf4') : '#f5f5f5'}; padding: 10px; margin: 8px 0; border-radius: 6px; border: 1px solid ${isWatching ? (isOverride ? '#fcd34d' : '#bbf7d0') : '#e0e0e0'};">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span>
                            <strong style="font-family: monospace;">${inst.host}</strong>
                            <span style="color: #666; font-size: 12px; margin-left: 8px;">[${inst.start}-${inst.end}] ${totalPixels}px</span>
                        </span>
                        <span style="display: flex; align-items: center; gap: 6px;">
                            ${simBadge}
                            ${statusBadge}
                            <button class="edit-btn" onclick="startEdit('${inst.host}', ${inst.start}, ${inst.end})" title="Edit">‚úé</button>
                            <button class="settings-toggle" onclick="toggleSettings('${inst.host}')" title="Settings">${isExpanded ? '‚ñ¥' : '‚ñæ'}</button>
                        </span>
                    </div>

                    ${isEditing ? `
                    <div class="edit-form" id="edit-form-${hostId}">
                        <div style="font-size: 11px; font-weight: 600; color: #854d0e; margin-bottom: 8px;">Edit Instance</div>
                        <div class="edit-form-row">
                            <input type="text" id="edit-host-${hostId}" value="${inst.host}" placeholder="IP / Hostname">
                            <input type="number" id="edit-start-${hostId}" value="${inst.start}" placeholder="Start">
                            <input type="number" id="edit-end-${hostId}" value="${inst.end}" placeholder="End">
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="saveEdit('${inst.host}')" class="btn" style="padding: 4px 12px; font-size: 12px; background: #eab308; color: white; border: none;">Save</button>
                            <button onclick="cancelEdit('${inst.host}')" class="btn" style="padding: 4px 12px; font-size: 12px; background: #f5f5f5; border: 1px solid #ccc;">Cancel</button>
                        </div>
                    </div>
                    ` : ''}

                    ${isWatching ? `
                        <div style="font-size: 12px; margin-bottom: 8px; padding: 6px 8px; background: #f8fafc; border-radius: 4px; border: 1px solid #e2e8f0;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: 500;">${inst.away_display || inst.away_team}</span>
                                <span style="font-family: monospace; font-weight: 600; font-size: 14px;">${inst.away_score ?? '-'}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 2px;">
                                <span style="font-weight: 500;">${inst.home_display || inst.home_team}</span>
                                <span style="font-family: monospace; font-weight: 600; font-size: 14px;">${inst.home_score ?? '-'}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 4px; padding-top: 4px; border-top: 1px solid #e2e8f0; font-size: 11px; color: #64748b;">
                                <span>${inst.period || ''}</span>
                                <span>${inst.home_win_pct !== undefined ? `${(inst.home_win_pct * 100).toFixed(0)}% ${inst.home_display || inst.home_team}` : ''}</span>
                            </div>
                        </div>
                    ` : ''}

                    <!-- Game selector - always visible -->
                    <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                        <select id="league-${inst.host}" onchange="loadGamesForInstance('${inst.host}')" style="flex: 1; padding: 4px 8px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;">
                            <option value="">League...</option>
                            ${leagues.map(l => `<option value="${l.id}">${l.name}</option>`).join('')}
                        </select>
                        <select id="game-${inst.host}" onchange="watchGameFromSelect('${inst.host}')" style="flex: 2; padding: 4px 8px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;" disabled>
                            <option value="">${isWatching ? 'Switch game...' : 'Select league first...'}</option>
                        </select>
                    </div>

                    ${stopButton}

                    <!-- Settings Panel -->
                    <div id="settings-${hostId}" class="instance-settings ${isExpanded ? '' : 'hidden'}">
                        <div class="section-label" style="margin-bottom: 6px;">Auto-Watch Teams</div>
                        <div class="watch-teams" id="watch-teams-${hostId}">
                            ${(inst.watch_teams || []).map(wt => `
                                <span class="watch-team-tag">
                                    ${wt}
                                    <button onclick="removeWatchTeam('${inst.host}', '${wt}')" title="Remove">√ó</button>
                                </span>
                            `).join('') || '<span style="font-size: 11px; color: #888;">No teams - games won\'t auto-start</span>'}
                        </div>
                        <div class="watch-add-form">
                            <select id="watch-league-${hostId}" onchange="loadWatchTeams('${inst.host}')">
                                <option value="">League...</option>
                                ${leagues.map(l => `<option value="${l.id}">${l.name}</option>`).join('')}
                            </select>
                            <select id="watch-team-${hostId}" disabled>
                                <option value="">Team...</option>
                            </select>
                            <button onclick="addWatchTeam('${inst.host}')" id="watch-add-btn-${hostId}" disabled>Add</button>
                        </div>
                        <div class="hint" style="margin: 4px 0 12px 0;">When a watched team is playing, their game auto-starts.</div>

                        <div class="section-label" style="margin-bottom: 8px;">Strip Preview</div>
                        <div style="position: relative;">
                            <div class="strip-preview" id="preview-${hostId}">
                                <div class="strip-segment home" style="width: ${homePctWidth}%">
                                    <span class="strip-label">${homePixels}px</span>
                                </div>
                                <div class="strip-segment buffer" style="width: ${bufferPctWidth}%"></div>
                                <div class="strip-segment divider" style="width: ${dividerPctWidth}%; background: ${dividerGradient};"></div>
                                <div class="strip-segment buffer" style="width: ${bufferPctWidth}%"></div>
                                <div class="strip-segment away" style="width: ${awayPctWidth}%">
                                    <span class="strip-label">${awayPixels}px</span>
                                </div>
                            </div>
                            <!-- Dignity markers -->
                            <div id="dignity-marker-left-${hostId}" class="dignity-marker" style="left: ${minPct * 100}%;" title="Min dignity: ${Math.round(minPct * 100)}%"></div>
                            <div id="dignity-marker-right-${hostId}" class="dignity-marker" style="right: ${minPct * 100}%;" title="Min dignity: ${Math.round(minPct * 100)}%"></div>
                        </div>

                        <div class="section-label" style="margin-bottom: 8px;">Display Settings</div>
                        <div class="settings-grid">
                            <div class="setting-row">
                                <span class="setting-label">Min Dignity</span>
                                <input type="range" class="setting-slider"
                                       id="dignity-${hostId}"
                                       min="1" max="20" value="${Math.round(minPct * 100)}"
                                       oninput="updateDignityPreview('${inst.host}', this.value); updateStripPreview('${inst.host}'); autoSaveInstanceSettings('${inst.host}')">
                                <span class="setting-value" id="dignity-value-${hostId}">${Math.round(minPct * 100)}%</span>
                            </div>
                            <div class="setting-row">
                                <span class="setting-label">Buffer</span>
                                <input type="range" class="setting-slider"
                                       id="buffer-${hostId}"
                                       min="0" max="20" value="${darkBufferPx}"
                                       oninput="updateStripPreview('${inst.host}'); autoSaveInstanceSettings('${inst.host}')">
                                <span class="setting-value" id="buffer-value-${hostId}">${darkBufferPx}px</span>
                            </div>
                            <div class="setting-row">
                                <span class="setting-label">Divider</span>
                                <input type="range" class="setting-slider"
                                       id="divider-${hostId}"
                                       min="2" max="30" value="${contestedPx}"
                                       oninput="updateStripPreview('${inst.host}'); autoSaveInstanceSettings('${inst.host}')">
                                <span class="setting-value" id="divider-value-${hostId}">${contestedPx}px</span>
                            </div>
                            <div class="setting-row">
                                <span class="setting-label">Style</span>
                                <select id="divider-preset-${hostId}"
                                        onchange="updateStripPreview('${inst.host}'); autoSaveInstanceSettings('${inst.host}')"
                                        style="flex: 1; padding: 2px 4px; font-size: 11px; border: 1px solid #ccc; border-radius: 4px;">
                                    <option value="classic" ${(inst.divider_preset || 'classic') === 'classic' ? 'selected' : ''}>Classic</option>
                                    <option value="intense" ${inst.divider_preset === 'intense' ? 'selected' : ''}>Intense</option>
                                    <option value="ice" ${inst.divider_preset === 'ice' ? 'selected' : ''}>Ice</option>
                                    <option value="pulse" ${inst.divider_preset === 'pulse' ? 'selected' : ''}>Pulse</option>
                                    <option value="chaos" ${inst.divider_preset === 'chaos' ? 'selected' : ''}>Chaos</option>
                                </select>
                            </div>
                            <div class="setting-row">
                                <span class="setting-label">Chase Speed</span>
                                <input type="range" class="setting-slider"
                                       id="chase-speed-${hostId}"
                                       min="50" max="255" value="${inst.chase_speed || 185}"
                                       oninput="document.getElementById('chase-speed-value-${hostId}').textContent = this.value; autoSaveInstanceSettings('${inst.host}')">
                                <span class="setting-value" id="chase-speed-value-${hostId}">${inst.chase_speed || 185}</span>
                            </div>
                            <div class="setting-row">
                                <span class="setting-label">Intensity</span>
                                <input type="range" class="setting-slider"
                                       id="chase-intensity-${hostId}"
                                       min="50" max="255" value="${inst.chase_intensity || 190}"
                                       oninput="document.getElementById('chase-intensity-value-${hostId}').textContent = this.value; autoSaveInstanceSettings('${inst.host}')">
                                <span class="setting-value" id="chase-intensity-value-${hostId}">${inst.chase_intensity || 190}</span>
                            </div>
                        </div>
                        <div class="hint" style="margin: 8px 0 0 0;">Battle zone total: <span id="battlezone-total-${hostId}">${battleZone}px</span></div>

                        <div class="section-label" style="margin: 12px 0 8px 0;">Post-Game Action</div>

                        <div class="settings-row">
                            <span class="settings-label">Action</span>
                            <select id="post-action-${hostId}"
                                    onchange="updatePostGameUI('${inst.host}'); autoSavePostGame('${inst.host}')"
                                    style="flex: 1; padding: 4px 8px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;">
                                <option value="flash_then_off" ${(inst.post_game_action || 'flash_then_off') === 'flash_then_off' ? 'selected' : ''}>Flash winner, fade off</option>
                                <option value="fade_off" ${inst.post_game_action === 'fade_off' ? 'selected' : ''}>Fade off</option>
                                <option value="off" ${inst.post_game_action === 'off' ? 'selected' : ''}>Off (immediate)</option>
                                <option value="restore" ${inst.post_game_action === 'restore' ? 'selected' : ''}>Restore previous preset</option>
                                <option value="preset" ${inst.post_game_action === 'preset' ? 'selected' : ''}>Switch to preset...</option>
                            </select>
                        </div>

                        <div class="settings-row" id="preset-row-${hostId}" style="${inst.post_game_action === 'preset' ? '' : 'display: none;'}">
                            <span class="settings-label">Preset ID</span>
                            <input type="number" id="post-preset-${hostId}"
                                   value="${inst.post_game_preset_id || ''}"
                                   placeholder="e.g. 1"
                                   onchange="autoSavePostGame('${inst.host}')"
                                   style="width: 80px; padding: 4px 8px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;">
                        </div>

                        <div class="hint" style="margin: 4px 0;">What happens when the game ends. "Restore" returns to whatever was playing before.</div>

                        <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
                            <button onclick="confirmDeleteInstance('${inst.host}')"
                                    style="background: none; border: none; color: #dc2626; font-size: 12px; cursor: pointer; padding: 4px 0;">
                                Remove this instance
                            </button>
                        </div>
                    </div>
                </div>
                `;
            }).join('');
        }

        function toggleSettings(host) {
            if (expandedSettings.has(host)) {
                expandedSettings.delete(host);
            } else {
                expandedSettings.add(host);
            }
            renderInstanceCards();
        }

        function startEdit(host, start, end) {
            editingInstances.add(host);
            renderInstanceCards();
        }

        function cancelEdit(host) {
            editingInstances.delete(host);
            renderInstanceCards();
        }

        async function saveEdit(originalHost) {
            const hostId = originalHost.replace(/\./g, '-');
            const newHost = document.getElementById(`edit-host-${hostId}`).value.trim();
            const newStart = parseInt(document.getElementById(`edit-start-${hostId}`).value) || 0;
            const newEnd = parseInt(document.getElementById(`edit-end-${hostId}`).value);

            if (!newHost) {
                alert('Please enter a valid IP address or hostname');
                return;
            }

            if (isNaN(newEnd) || newEnd <= newStart) {
                alert('End pixel must be greater than start pixel');
                return;
            }

            try {
                const resp = await fetch(`/api/instance/${originalHost}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        host: newHost !== originalHost ? newHost : null,
                        start: newStart,
                        end: newEnd
                    })
                });

                const result = await resp.json();

                if (!resp.ok) {
                    alert(result.detail || 'Failed to update instance');
                    return;
                }

                // Update expandedSettings if host changed
                if (newHost !== originalHost && expandedSettings.has(originalHost)) {
                    expandedSettings.delete(originalHost);
                    expandedSettings.add(newHost);
                }

                editingInstances.delete(originalHost);
                await loadInstances();
            } catch (err) {
                alert('Error saving: ' + err.message);
            }
        }

        function updateDignityPreview(host, pctValue) {
            const hostId = host.replace(/\./g, '-');
            const inst = instanceStates.find(i => i.host === host);
            if (!inst) return;

            const minPct = parseInt(pctValue) / 100;
            const totalPixels = inst.end - inst.start;
            const contestedPx = inst.contested_zone_pixels || 6;
            const darkBufferPx = inst.dark_buffer_pixels || 4;
            const battleZone = contestedPx + (darkBufferPx * 2);
            const availablePixels = totalPixels - battleZone;
            const minDignityPixels = Math.round(availablePixels * minPct);

            // Update value display
            document.getElementById(`dignity-value-${hostId}`).textContent = `${pctValue}% (${minDignityPixels}px)`;

            // Update marker positions
            const leftMarker = document.getElementById(`dignity-marker-left-${hostId}`);
            const rightMarker = document.getElementById(`dignity-marker-right-${hostId}`);
            if (leftMarker) {
                leftMarker.style.left = `${minPct * 100}%`;
                leftMarker.title = `Min dignity: ${pctValue}%`;
            }
            if (rightMarker) {
                rightMarker.style.right = `${minPct * 100}%`;
                rightMarker.title = `Min dignity: ${pctValue}%`;
            }
        }

        // Divider preset colors for preview
        const DIVIDER_PRESETS = {
            classic: { color: 'rgb(200, 80, 0)', gradient: 'linear-gradient(90deg, #c85000, #ff8c00, #c85000)' },
            intense: { color: 'rgb(255, 50, 0)', gradient: 'linear-gradient(90deg, #cc0000, #ff3300, #cc0000)' },
            ice: { color: 'rgb(100, 150, 255)', gradient: 'linear-gradient(90deg, #4080ff, #80b0ff, #4080ff)' },
            pulse: { color: 'rgb(200, 200, 200)', gradient: 'linear-gradient(90deg, #aaa, #ddd, #aaa)' },
            chaos: { color: 'rgb(255, 100, 0)', gradient: 'linear-gradient(90deg, #ff4400, #ff8800, #ff4400)' },
        };

        function updateStripPreview(host) {
            const hostId = host.replace(/\./g, '-');
            const inst = instanceStates.find(i => i.host === host);
            if (!inst) return;

            const bufferSlider = document.getElementById(`buffer-${hostId}`);
            const dividerSlider = document.getElementById(`divider-${hostId}`);
            const dignitySlider = document.getElementById(`dignity-${hostId}`);
            const presetSelect = document.getElementById(`divider-preset-${hostId}`);

            const bufferPx = parseInt(bufferSlider.value);
            const dividerPx = parseInt(dividerSlider.value);
            const minPct = parseInt(dignitySlider.value) / 100;
            const preset = presetSelect?.value || 'classic';
            const totalPx = (bufferPx * 2) + dividerPx;

            // Update text displays
            document.getElementById(`buffer-value-${hostId}`).textContent = `${bufferPx}px`;
            document.getElementById(`divider-value-${hostId}`).textContent = `${dividerPx}px`;
            document.getElementById(`battlezone-total-${hostId}`).textContent = `${totalPx}px`;

            // Calculate strip segments
            const totalPixels = inst.end - inst.start;
            const battleZone = totalPx;
            const availablePixels = totalPixels - battleZone;
            const previewPct = inst.watching && inst.home_win_pct !== undefined ? inst.home_win_pct : 0.5;
            const clampedPct = Math.max(minPct, Math.min(1 - minPct, previewPct));
            const homePixels = Math.round(availablePixels * clampedPct);
            const awayPixels = availablePixels - homePixels;

            // Convert to percentages
            const homePctWidth = (homePixels / totalPixels * 100).toFixed(1);
            const bufferPctWidth = (bufferPx / totalPixels * 100).toFixed(1);
            const dividerPctWidth = (dividerPx / totalPixels * 100).toFixed(1);
            const awayPctWidth = (awayPixels / totalPixels * 100).toFixed(1);

            // Get divider style from preset
            const dividerStyle = DIVIDER_PRESETS[preset] || DIVIDER_PRESETS.classic;

            // Update preview
            const preview = document.getElementById(`preview-${hostId}`);
            if (preview) {
                preview.innerHTML = `
                    <div class="strip-segment home" style="width: ${homePctWidth}%">
                        <span class="strip-label">${homePixels}px</span>
                    </div>
                    <div class="strip-segment buffer" style="width: ${bufferPctWidth}%"></div>
                    <div class="strip-segment divider" style="width: ${dividerPctWidth}%; background: ${dividerStyle.gradient};">
                    </div>
                    <div class="strip-segment buffer" style="width: ${bufferPctWidth}%"></div>
                    <div class="strip-segment away" style="width: ${awayPctWidth}%">
                        <span class="strip-label">${awayPixels}px</span>
                    </div>
                `;
            }
        }

        // Debounced auto-save for instance settings
        const saveTimers = {};
        function autoSaveInstanceSettings(host) {
            // Debounce - wait 500ms after last change before saving
            if (saveTimers[host]) clearTimeout(saveTimers[host]);
            saveTimers[host] = setTimeout(() => saveInstanceSettings(host), 500);
        }

        async function saveInstanceSettings(host) {
            const hostId = host.replace(/\./g, '-');
            const dignitySlider = document.getElementById(`dignity-${hostId}`);
            const bufferSlider = document.getElementById(`buffer-${hostId}`);
            const dividerSlider = document.getElementById(`divider-${hostId}`);
            const dividerPresetSelect = document.getElementById(`divider-preset-${hostId}`);
            const chaseSpeedSlider = document.getElementById(`chase-speed-${hostId}`);
            const chaseIntensitySlider = document.getElementById(`chase-intensity-${hostId}`);

            const settings = {
                min_team_pct: parseInt(dignitySlider.value) / 100,
                dark_buffer_pixels: parseInt(bufferSlider.value),
                contested_zone_pixels: parseInt(dividerSlider.value),
                divider_preset: dividerPresetSelect.value,
                chase_speed: parseInt(chaseSpeedSlider.value),
                chase_intensity: parseInt(chaseIntensitySlider.value),
            };

            const resp = await fetch(`/api/instance/${host}/settings`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            });

            if (!resp.ok) {
                console.error('Failed to save settings for', host);
            }
            // Don't reload - let the periodic refresh handle it to avoid UI flicker
        }

        // Post-game settings
        function updatePostGameUI(host) {
            const hostId = host.replace(/\./g, '-');
            const action = document.getElementById(`post-action-${hostId}`).value;
            const presetRow = document.getElementById(`preset-row-${hostId}`);
            presetRow.style.display = action === 'preset' ? '' : 'none';
        }

        const postGameTimers = {};
        function autoSavePostGame(host) {
            if (postGameTimers[host]) clearTimeout(postGameTimers[host]);
            postGameTimers[host] = setTimeout(() => savePostGame(host), 500);
        }

        async function savePostGame(host) {
            const hostId = host.replace(/\./g, '-');
            const action = document.getElementById(`post-action-${hostId}`).value;
            const presetInput = document.getElementById(`post-preset-${hostId}`);
            const presetId = presetInput.value ? parseInt(presetInput.value) : null;

            const settings = {
                action: action,
                preset_id: presetId,
            };

            const resp = await fetch(`/api/instance/${host}/post_game`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            });

            if (!resp.ok) {
                console.error('Failed to save post-game settings for', host);
            }
        }

        // Watch Teams management
        async function loadWatchTeams(host) {
            const hostId = host.replace(/\./g, '-');
            const leagueSelect = document.getElementById(`watch-league-${hostId}`);
            const teamSelect = document.getElementById(`watch-team-${hostId}`);
            const addBtn = document.getElementById(`watch-add-btn-${hostId}`);
            const league = leagueSelect.value;

            if (!league) {
                teamSelect.innerHTML = '<option value="">Team...</option>';
                teamSelect.disabled = true;
                addBtn.disabled = true;
                return;
            }

            teamSelect.innerHTML = '<option value="">Loading...</option>';
            const resp = await fetch(`/api/teams/${league}`);
            const teams = await resp.json();

            teamSelect.innerHTML = '<option value="">Team...</option>' +
                teams.map(t => `<option value="${t.id}">${t.name}</option>`).join('');
            teamSelect.disabled = false;

            teamSelect.onchange = () => {
                addBtn.disabled = !teamSelect.value;
            };
        }

        async function addWatchTeam(host) {
            const hostId = host.replace(/\./g, '-');
            const leagueSelect = document.getElementById(`watch-league-${hostId}`);
            const teamSelect = document.getElementById(`watch-team-${hostId}`);

            const league = leagueSelect.value;
            const team = teamSelect.value;
            if (!league || !team) return;

            const teamSpec = `${league}:${team}`;

            // Get current watch teams
            const inst = instanceStates.find(i => i.host === host);
            const current = inst?.watch_teams || [];

            // Don't add duplicates
            if (current.includes(teamSpec)) {
                alert('Team already in watch list');
                return;
            }

            const newList = [...current, teamSpec];

            await fetch(`/api/instance/${host}/watch_teams`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ watch_teams: newList })
            });

            // Reset dropdowns
            leagueSelect.value = '';
            teamSelect.innerHTML = '<option value="">Team...</option>';
            teamSelect.disabled = true;
            document.getElementById(`watch-add-btn-${hostId}`).disabled = true;

            await loadInstances();
        }

        async function removeWatchTeam(host, teamSpec) {
            const inst = instanceStates.find(i => i.host === host);
            const current = inst?.watch_teams || [];
            const newList = current.filter(t => t !== teamSpec);

            await fetch(`/api/instance/${host}/watch_teams`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ watch_teams: newList })
            });

            await loadInstances();
        }

        async function loadGamesForInstance(host) {
            const leagueSelect = document.getElementById(`league-${host}`);
            const gameSelect = document.getElementById(`game-${host}`);
            const league = leagueSelect.value;

            if (!league) {
                gameSelect.innerHTML = '<option value="">Select league first...</option>';
                gameSelect.disabled = true;
                return;
            }

            gameSelect.innerHTML = '<option value="">Loading...</option>';
            const resp = await fetch(`/api/games/${league}`);
            const games = await resp.json();

            if (games.length === 0) {
                gameSelect.innerHTML = '<option value="">No games available</option>';
                gameSelect.disabled = true;
            } else {
                gameSelect.innerHTML = games.map(g =>
                    `<option value="${g.id}">${g.away_display} @ ${g.home_display} (${g.detail})</option>`
                ).join('');
                gameSelect.disabled = false;
            }
        }

        // Selecting a game immediately starts watching
        async function watchGameFromSelect(host) {
            const leagueSelect = document.getElementById(`league-${host}`);
            const gameSelect = document.getElementById(`game-${host}`);

            if (!leagueSelect.value || !gameSelect.value) {
                return;  // No selection yet
            }

            await fetch(`/api/instance/${host}/watch`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    league: leagueSelect.value,
                    game_id: gameSelect.value
                })
            });

            await loadInstances();
        }

        async function stopInstance(host) {
            await fetch(`/api/instance/${host}/stop`, { method: 'POST' });
            await loadInstances();
        }

        async function confirmDeleteInstance(host) {
            if (!confirm(`Remove ${host} from Scoreline?\n\nThis will remove the instance from your config. The WLED device itself is not affected.`)) {
                return;
            }

            const resp = await fetch(`/api/instance/${host}`, { method: 'DELETE' });
            const result = await resp.json();

            if (result.status === 'removed') {
                expandedSettings.delete(host);
                await loadInstances();
            } else {
                alert(result.message || 'Failed to remove instance');
            }
        }

        // WLED Discovery
        document.getElementById('scan-btn').addEventListener('click', scanForDevices);

        async function scanForDevices() {
            const btn = document.getElementById('scan-btn');
            const discoveredList = document.getElementById('discovered-list');
            const discoveredDevices = document.getElementById('discovered-devices');

            btn.textContent = 'Scanning...';
            btn.disabled = true;

            try {
                const resp = await fetch('/api/discover');
                const devices = await resp.json();

                if (devices.length === 0) {
                    discoveredDevices.innerHTML = '<div style="color: #666; font-size: 12px;">No WLED devices found</div>';
                } else {
                    discoveredDevices.innerHTML = devices.map(d => `
                        <div class="status-row" style="background: #fff; padding: 6px 10px; margin: 4px 0; border-radius: 4px; border: 1px solid #e0e7ff; display: flex; justify-content: space-between; align-items: center;">
                            <span>
                                <strong>${d.name}</strong>
                                <span style="font-family: monospace; font-size: 12px; color: #666; margin-left: 8px;">${d.ip}</span>
                            </span>
                            ${d.configured
                                ? '<span style="font-size: 11px; color: #22c55e; font-weight: 500;">Added</span>'
                                : `<button onclick="addDevice('${d.ip}', '${d.name}')" class="btn" style="padding: 2px 8px; font-size: 11px; background: #0066cc; color: white; border: none;">Add</button>`
                            }
                        </div>
                    `).join('');
                }
                discoveredList.classList.remove('hidden');
            } catch (e) {
                discoveredDevices.innerHTML = '<div style="color: #dc2626; font-size: 12px;">Scan failed</div>';
                discoveredList.classList.remove('hidden');
            }

            btn.textContent = 'Scan Network';
            btn.disabled = false;
        }

        async function addDevice(ip, name) {
            const resp = await fetch('/api/wled/add', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ host: ip, start: 0, end: 300 })
            });

            const result = await resp.json();

            if (result.status === 'added') {
                // Refresh both lists
                await loadInstances();
                await scanForDevices();
            }
        }

        // Manual WLED Add Form
        document.getElementById('add-wled-btn').addEventListener('click', () => {
            document.getElementById('add-wled-form').classList.remove('hidden');
            document.getElementById('add-wled-host').focus();
        });

        document.getElementById('add-wled-cancel').addEventListener('click', () => {
            document.getElementById('add-wled-form').classList.add('hidden');
            document.getElementById('add-wled-host').value = '';
            document.getElementById('add-wled-start').value = '0';
            document.getElementById('add-wled-end').value = '';
        });

        document.getElementById('add-wled-submit').addEventListener('click', async () => {
            const host = document.getElementById('add-wled-host').value.trim();
            const start = parseInt(document.getElementById('add-wled-start').value) || 0;
            const end = parseInt(document.getElementById('add-wled-end').value);

            if (!host) {
                alert('Please enter an IP address');
                return;
            }
            if (isNaN(end)) {
                alert('Please enter the end LED index');
                return;
            }

            const btn = document.getElementById('add-wled-submit');
            btn.textContent = 'Adding...';
            btn.disabled = true;

            try {
                const resp = await fetch('/api/wled/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ host, start, end })
                });

                const result = await resp.json();

                if (result.status === 'added') {
                    // Clear form and hide
                    document.getElementById('add-wled-form').classList.add('hidden');
                    document.getElementById('add-wled-host').value = '';
                    document.getElementById('add-wled-start').value = '0';
                    document.getElementById('add-wled-end').value = '';
                    // Refresh list
                    await loadInstances();
                } else if (result.status === 'exists') {
                    alert('This WLED device is already configured');
                }
            } catch (e) {
                alert('Failed to add device');
            }

            btn.textContent = 'Add';
            btn.disabled = false;
        });

        // Simulator controls
        const simLeague = document.getElementById('sim-league');
        const simAway = document.getElementById('sim-away');
        const simHome = document.getElementById('sim-home');
        const testSlider = document.getElementById('test-slider');

        // Team colors cache for preview - gray defaults
        const GRAY_TEAM = [[100, 100, 100], [60, 60, 60]];
        let simTeamColors = { home: GRAY_TEAM, away: GRAY_TEAM };
        let autoPlayInterval = null;
        let autoPlayDirection = 1;

        // Simulator settings state
        let simSettings = {
            min_team_pct: 0.05,
            dark_buffer_pixels: 4,
            contested_zone_pixels: 6,
            divider_preset: 'classic',
            chase_speed: 185,
            chase_intensity: 190,
        };

        function renderSimTargetToggles() {
            const container = document.getElementById('sim-targets');
            if (!container) return;

            if (instanceStates.length === 0) {
                container.innerHTML = '<span style="font-size: 11px; color: #888;">No instances configured</span>';
                return;
            }

            container.innerHTML = instanceStates.map(inst => {
                const liveBadge = inst.watching ? '<span class="live-badge">LIVE</span>' : '';
                return `
                    <div class="sim-target-row">
                        <span class="sim-target-label">
                            ${inst.host}
                            ${liveBadge}
                        </span>
                        <label class="toggle-switch">
                            <input type="checkbox" ${inst.simulating ? 'checked' : ''} onchange="toggleSimTarget('${inst.host}')">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                `;
            }).join('');
        }

        // Debounce timer for simulator updates
        let simUpdateTimer = null;

        function updateSimSettings() {
            // Update value displays immediately (responsive UI)
            const dignity = document.getElementById('sim-dignity').value;
            const buffer = document.getElementById('sim-buffer').value;
            const divider = document.getElementById('sim-divider').value;
            const preset = document.getElementById('sim-divider-preset').value;
            const speed = document.getElementById('sim-chase-speed').value;
            const intensity = document.getElementById('sim-chase-intensity').value;

            document.getElementById('sim-dignity-value').textContent = dignity + '%';
            document.getElementById('sim-buffer-value').textContent = buffer + 'px';
            document.getElementById('sim-divider-value').textContent = divider + 'px';
            document.getElementById('sim-chase-speed-value').textContent = speed;
            document.getElementById('sim-chase-intensity-value').textContent = intensity;

            // Update settings state
            simSettings = {
                min_team_pct: parseInt(dignity) / 100,
                dark_buffer_pixels: parseInt(buffer),
                contested_zone_pixels: parseInt(divider),
                divider_preset: preset,
                chase_speed: parseInt(speed),
                chase_intensity: parseInt(intensity),
            };

            // Update preview immediately (local, no network)
            updateSimPreview(parseInt(document.getElementById('test-slider').value));

            // Debounce the WLED update - wait 150ms after last change
            if (simUpdateTimer) clearTimeout(simUpdateTimer);
            simUpdateTimer = setTimeout(() => updateSimulator(), 150);
        }

        async function toggleSimTarget(host) {
            const inst = instanceStates.find(i => i.host === host);
            if (!inst) return;

            if (inst.simulating) {
                // Stop simulation
                await fetch(`/api/instance/${host}/sim/stop`, { method: 'POST' });
            } else {
                // Start simulation - check for warning
                const resp = await fetch(`/api/instance/${host}/sim/start`, { method: 'POST' });
                const result = await resp.json();

                if (result.warning) {
                    // Show warning but proceed (already started)
                    console.log(`[SIM] Warning: ${result.warning}`);
                    // Optional: show a brief toast or indicator
                }
            }

            // Refresh state
            await loadInstances();

            // If we just started sim and have teams selected, push the colors immediately
            if (!inst.simulating && simLeague.value && simAway.value && simHome.value) {
                await updateSimulator();
            }
        }

        async function updateSimulator() {
            const league = simLeague.value;
            const away = simAway.value;
            const home = simHome.value;
            const pct = parseInt(testSlider.value);

            // Get simulating instances from backend state
            const simInstances = instanceStates.filter(i => i.simulating);

            document.getElementById('test-pct').textContent = pct + '%';
            updateSimPreview(pct);

            // Update targeted instance preview(s) to match simulator
            if (league && away && home && simTeamColors.home && simTeamColors.away) {
                updateInstanceSimPreview(pct);
            }

            // Only send to instances that are in sim mode
            if (league && away && home && simInstances.length > 0) {
                for (const inst of simInstances) {
                    await fetch('/api/test', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pct: pct,
                            league: league,
                            home: home,
                            away: away,
                            host: inst.host,
                            // Include simulator display settings
                            settings: simSettings
                        })
                    });
                }
            }
        }

        function updateInstanceSimPreview(pct) {
            // Update the strip preview on simulating instance card(s)
            const targets = instanceStates.filter(i => i.simulating);

            for (const inst of targets) {
                const hostId = inst.host.replace(/\./g, '-');
                const preview = document.getElementById(`preview-${hostId}`);
                if (!preview) continue;

                const minPct = inst.min_team_pct || 0.05;
                const contestedPx = inst.contested_zone_pixels || 6;
                const darkBufferPx = inst.dark_buffer_pixels || 4;
                const totalPixels = inst.end - inst.start;
                const battleZone = contestedPx + (darkBufferPx * 2);
                const availablePixels = totalPixels - battleZone;

                const homePct = pct / 100;
                const clampedPct = Math.max(minPct, Math.min(1 - minPct, homePct));
                const homePixels = Math.round(availablePixels * clampedPct);
                const awayPixels = availablePixels - homePixels;

                const homePctWidth = (homePixels / totalPixels * 100).toFixed(1);
                const bufferPctWidth = (darkBufferPx / totalPixels * 100).toFixed(1);
                const dividerPctWidth = (contestedPx / totalPixels * 100).toFixed(1);
                const awayPctWidth = (awayPixels / totalPixels * 100).toFixed(1);

                const presetGradients = {
                    classic: 'linear-gradient(90deg, #c85000, #ff8c00, #c85000)',
                    intense: 'linear-gradient(90deg, #cc0000, #ff3300, #cc0000)',
                    ice: 'linear-gradient(90deg, #4080ff, #80b0ff, #4080ff)',
                    pulse: 'linear-gradient(90deg, #aaa, #ddd, #aaa)',
                    chaos: 'linear-gradient(90deg, #ff4400, #ff8800, #ff4400)',
                };
                const dividerGradient = presetGradients[inst.divider_preset] || presetGradients.classic;

                const hc = simTeamColors.home;
                const ac = simTeamColors.away;

                preview.innerHTML = `
                    <div class="strip-segment" style="width: ${homePctWidth}%; background: linear-gradient(90deg, rgb(${hc[0].join(',')}) 0%, rgb(${hc[1].join(',')}) 100%);">
                        <span class="strip-label">${homePixels}px</span>
                    </div>
                    <div class="strip-segment buffer" style="width: ${bufferPctWidth}%"></div>
                    <div class="strip-segment divider" style="width: ${dividerPctWidth}%; background: ${dividerGradient};"></div>
                    <div class="strip-segment buffer" style="width: ${bufferPctWidth}%"></div>
                    <div class="strip-segment" style="width: ${awayPctWidth}%; background: linear-gradient(90deg, rgb(${ac[0].join(',')}) 0%, rgb(${ac[1].join(',')}) 100%);">
                        <span class="strip-label">${awayPixels}px</span>
                    </div>
                `;
            }
        }

        function updateSimPreview(pct) {
            const preview = document.getElementById('sim-preview');
            if (!preview) return;

            // Use simulator settings for preview
            const minPct = simSettings.min_team_pct;
            const contestedPx = simSettings.contested_zone_pixels;
            const darkBufferPx = simSettings.dark_buffer_pixels;

            // Use first instance's pixel count for preview, or default
            const inst = instanceStates[0];
            const totalPixels = inst ? (inst.end - inst.start) : 300;

            const battleZone = contestedPx + (darkBufferPx * 2);
            const availablePixels = totalPixels - battleZone;

            const homePct = pct / 100;
            const clampedPct = Math.max(minPct, Math.min(1 - minPct, homePct));
            const homePixels = Math.round(availablePixels * clampedPct);
            const awayPixels = availablePixels - homePixels;

            const homePctWidth = (homePixels / totalPixels * 100).toFixed(1);
            const bufferPctWidth = (darkBufferPx / totalPixels * 100).toFixed(1);
            const dividerPctWidth = (contestedPx / totalPixels * 100).toFixed(1);
            const awayPctWidth = (awayPixels / totalPixels * 100).toFixed(1);

            const presetGradients = {
                classic: 'linear-gradient(90deg, #c85000, #ff8c00, #c85000)',
                intense: 'linear-gradient(90deg, #cc0000, #ff3300, #cc0000)',
                ice: 'linear-gradient(90deg, #4080ff, #80b0ff, #4080ff)',
                pulse: 'linear-gradient(90deg, #aaa, #ddd, #aaa)',
                chaos: 'linear-gradient(90deg, #ff4400, #ff8800, #ff4400)',
            };
            const dividerGradient = presetGradients[simSettings.divider_preset] || presetGradients.classic;

            const hc = simTeamColors.home;
            const ac = simTeamColors.away;

            // Render home on left, away on right to match WLED segment layout
            preview.innerHTML = `
                <div class="strip-segment" style="width: ${homePctWidth}%; background: linear-gradient(90deg, rgb(${hc[0].join(',')}) 0%, rgb(${hc[1].join(',')}) 100%);"></div>
                <div class="strip-segment buffer" style="width: ${bufferPctWidth}%"></div>
                <div class="strip-segment divider" style="width: ${dividerPctWidth}%; background: ${dividerGradient};"></div>
                <div class="strip-segment buffer" style="width: ${bufferPctWidth}%"></div>
                <div class="strip-segment" style="width: ${awayPctWidth}%; background: linear-gradient(90deg, rgb(${ac[0].join(',')}) 0%, rgb(${ac[1].join(',')}) 100%);"></div>
                <div class="dignity-marker" style="left: ${minPct * 100}%;" title="Min dignity: ${Math.round(minPct * 100)}%"></div>
                <div class="dignity-marker" style="right: ${minPct * 100}%;" title="Min dignity: ${Math.round(minPct * 100)}%"></div>
            `;
        }

        // Auto-start sim on first available instance if none running
        async function ensureSimRunning() {
            const simInstances = instanceStates.filter(i => i.simulating);
            if (simInstances.length === 0 && instanceStates.length > 0) {
                // Start sim on first instance
                const host = instanceStates[0].host;
                await fetch(`/api/instance/${host}/sim/start`, { method: 'POST' });
                await loadInstances();
                return true;
            }
            return simInstances.length > 0;
        }

        async function playScenario(pct) {
            // Stop any running animation
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }

            // Ensure sim is running
            const hasTeams = simLeague.value && simAway.value && simHome.value;
            if (!hasTeams) {
                alert('Select a league and both teams first');
                return;
            }

            await ensureSimRunning();
            testSlider.value = pct;
            updateSimulator();
        }

        // Helper to manage animated scenario buttons
        function setActiveAnim(animName) {
            document.querySelectorAll('.anim-btn').forEach(b => b.classList.remove('active'));
            if (animName) {
                document.querySelector(`.anim-btn[data-anim="${animName}"]`)?.classList.add('active');
            }
            updateStopButton();
        }

        function clearAnim() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            setActiveAnim(null);
        }

        async function startAnim(animName) {
            clearAnim();
            const hasTeams = simLeague.value && simAway.value && simHome.value;
            if (!hasTeams) {
                alert('Select a league and both teams first');
                return false;
            }
            await ensureSimRunning();
            setActiveAnim(animName);
            return true;
        }

        async function playComeback() {
            if (!await startAnim('comeback')) return;

            let pct = 15;
            testSlider.value = pct;
            updateSimulator();

            autoPlayInterval = setInterval(() => {
                pct += 2;
                if (pct >= 85) {
                    clearAnim();
                    pct = 85;
                }
                testSlider.value = pct;
                updateSimulator();
            }, 300);
        }

        async function playCollapse() {
            if (!await startAnim('collapse')) return;

            let pct = 85;
            testSlider.value = pct;
            updateSimulator();

            autoPlayInterval = setInterval(() => {
                pct -= 2;
                if (pct <= 15) {
                    clearAnim();
                    pct = 15;
                }
                testSlider.value = pct;
                updateSimulator();
            }, 300);
        }

        async function playOvertime() {
            if (!await startAnim('overtime')) return;

            let pct = 50;
            testSlider.value = pct;
            updateSimulator();

            // Nervous jittering around 50%
            autoPlayInterval = setInterval(() => {
                const jitter = (Math.random() - 0.5) * 8;  // ¬±4%
                pct = 50 + jitter;
                pct = Math.max(42, Math.min(58, pct));
                testSlider.value = Math.round(pct);
                updateSimulator();
            }, 150);
        }

        async function playMomentum() {
            if (!await startAnim('momentum')) return;

            let pct = 50;
            let direction = 1;
            testSlider.value = pct;
            updateSimulator();

            // Pendulum swings
            autoPlayInterval = setInterval(() => {
                pct += direction * 3;
                if (pct >= 80) direction = -1;
                if (pct <= 20) direction = 1;
                testSlider.value = Math.round(pct);
                updateSimulator();
            }, 200);
        }

        async function playBuzzerBeater() {
            if (!await startAnim('buzzer')) return;

            // Start losing badly
            let pct = 25;
            let phase = 'creep';  // creep ‚Üí dramatic pause ‚Üí win
            testSlider.value = pct;
            updateSimulator();

            autoPlayInterval = setInterval(() => {
                if (phase === 'creep') {
                    // Slow creep toward even
                    pct += 0.8;
                    if (pct >= 48) {
                        phase = 'pause';
                        setTimeout(() => { phase = 'win'; }, 800);
                    }
                } else if (phase === 'win') {
                    // Sudden jump to victory!
                    pct += 8;
                    if (pct >= 88) {
                        clearAnim();
                        pct = 88;
                    }
                }
                testSlider.value = Math.round(pct);
                updateSimulator();
            }, 250);
        }

        async function stopSim() {
            const btn = document.getElementById('stop-btn');
            if (!btn.classList.contains('enabled')) return;

            // Stop any animation
            clearAnim();

            // Stop all simulating instances
            const simInstances = instanceStates.filter(i => i.simulating);
            for (const inst of simInstances) {
                await fetch(`/api/instance/${inst.host}/sim/stop`, { method: 'POST' });
            }
            await loadInstances();
        }

        simLeague.addEventListener('change', async () => {
            const league = simLeague.value;
            if (!league) {
                simAway.disabled = true;
                simHome.disabled = true;
                // Reset to gray team colors
                simTeamColors = { home: GRAY_TEAM, away: GRAY_TEAM };
                updateSimPreview(parseInt(testSlider.value));
                return;
            }

            const resp = await fetch(`/api/teams/${league}`);
            const teams = await resp.json();

            const options = '<option value="">Pick team...</option>' +
                teams.map(t => `<option value="${t.id}">${t.name}</option>`).join('');

            simAway.innerHTML = options;
            simHome.innerHTML = options;
            simAway.disabled = false;
            simHome.disabled = false;

            // Store teams for color lookup
            simLeague._teams = teams;
        });

        simAway.addEventListener('change', async () => {
            const label = simAway.options[simAway.selectedIndex]?.text || 'Away';
            document.getElementById('sim-away-label').textContent = label;

            if (simLeague._teams && simAway.value) {
                const team = simLeague._teams.find(t => t.id === simAway.value);
                simTeamColors.away = team?.colors || GRAY_TEAM;
            } else {
                simTeamColors.away = GRAY_TEAM;
            }
            updateSimulator();
        });

        simHome.addEventListener('change', async () => {
            const label = simHome.options[simHome.selectedIndex]?.text || 'Home';
            document.getElementById('sim-home-label').textContent = label;

            if (simLeague._teams && simHome.value) {
                const team = simLeague._teams.find(t => t.id === simHome.value);
                simTeamColors.home = team?.colors || GRAY_TEAM;
            } else {
                simTeamColors.home = GRAY_TEAM;
            }
            updateSimulator();
        });

        testSlider.addEventListener('input', () => {
            // Update display immediately
            document.getElementById('test-pct').textContent = testSlider.value + '%';
            updateSimPreview(parseInt(testSlider.value));
            // Debounce WLED update
            if (simUpdateTimer) clearTimeout(simUpdateTimer);
            simUpdateTimer = setTimeout(() => updateSimulator(), 100);
        });

        // Load simulator defaults from server
        async function loadSimDefaults() {
            try {
                const resp = await fetch('/api/simulator');
                const defaults = await resp.json();

                // Set slider
                if (defaults.win_pct !== undefined) {
                    testSlider.value = defaults.win_pct;
                    document.getElementById('test-pct').textContent = defaults.win_pct + '%';
                }

                // Set league first, then load teams
                if (defaults.league) {
                    simLeague.value = defaults.league;
                    // Trigger team loading
                    const teamsResp = await fetch(`/api/teams/${defaults.league}`);
                    const teams = await teamsResp.json();
                    simLeague._teams = teams;

                    const options = '<option value="">Pick team...</option>' +
                        teams.map(t => `<option value="${t.id}">${t.name}</option>`).join('');
                    simAway.innerHTML = options;
                    simHome.innerHTML = options;
                    simAway.disabled = false;
                    simHome.disabled = false;

                    // Set selected teams
                    if (defaults.away) {
                        simAway.value = defaults.away;
                        const awayTeam = teams.find(t => t.id === defaults.away);
                        if (awayTeam) {
                            simTeamColors.away = awayTeam.colors || GRAY_TEAM;
                            document.getElementById('sim-away-label').textContent = awayTeam.name;
                        }
                    }
                    if (defaults.home) {
                        simHome.value = defaults.home;
                        const homeTeam = teams.find(t => t.id === defaults.home);
                        if (homeTeam) {
                            simTeamColors.home = homeTeam.colors || GRAY_TEAM;
                            document.getElementById('sim-home-label').textContent = homeTeam.name;
                        }
                    }
                }

                // Update preview with loaded values
                updateSimPreview(parseInt(testSlider.value));
            } catch (e) {
                console.log('No saved simulator defaults');
            }
        }

        // Save current simulator state as defaults
        async function saveSimDefaults() {
            const btn = document.getElementById('save-sim-btn');
            const league = simLeague.value;
            const home = simHome.value;
            const away = simAway.value;
            const pct = parseInt(testSlider.value);

            if (!league || !home || !away) {
                alert('Select a league and both teams first');
                return;
            }

            btn.textContent = '...';
            btn.disabled = true;

            try {
                await fetch('/api/simulator', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ league, home, away, win_pct: pct })
                });
                btn.textContent = '‚úì Saved';
                setTimeout(() => {
                    btn.textContent = 'üíæ Save';
                    btn.disabled = false;
                }, 1500);
            } catch (e) {
                btn.textContent = 'üíæ Save';
                btn.disabled = false;
                alert('Failed to save');
            }
        }

        // Initialize simulator leagues dropdown and preview
        (async function initSimulator() {
            const resp = await fetch('/api/leagues');
            const simLeagues = await resp.json();
            simLeague.innerHTML = '<option value="">League...</option>' +
                simLeagues.map(l => `<option value="${l.id}">${l.name}</option>`).join('');

            // Load saved defaults (will populate league/teams/pct)
            await loadSimDefaults();

            // Show preview with loaded or default values
            updateSimPreview(parseInt(testSlider.value));
        })();

        // Initial load
        async function init() {
            // Load leagues (needed for instance card dropdowns)
            const resp = await fetch('/api/leagues');
            leagues = await resp.json();

            // Load instances
            await loadInstances();

            // Populate simulator target toggles
            renderSimTargetToggles();

            // Periodic refresh for live scores (skip if user is interacting with form)
            setInterval(() => {
                const active = document.activeElement;
                if (active && active.matches('input, select, textarea')) {
                    return; // Don't refresh while user is typing/selecting
                }
                loadInstances();
            }, 10000);
        }

        init();

        // Global keyboard shortcuts (respecting input focus)
        document.addEventListener('keydown', (e) => {
            if (e.target.matches('input, select, textarea')) {
                return;
            }
            // Could add global shortcuts here
        });
    </script>
</body>
</html>
